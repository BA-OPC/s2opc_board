/*
 * Licensed to Systerel under one or more contributor license
 * agreements. See the NOTICE file distributed with this work
 * for additional information regarding copyright ownership.
 * Systerel licenses this file to you under the Apache
 * License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain
 * a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

IMPLEMENTATION
    service_add_nodes_1_i

REFINES
    service_add_nodes_1

SEES
    constants,
    constants_statuscodes_bs,
    message_in_bs,
    message_out_bs

DEFINITIONS
    "address_space.def"

IMPORTS
    service_write

/* Note: We would like to use EXTENDS instead of IMPORTS + PROMOTES,
   but it would trigger a bug in the project check. */

PROMOTES
    treat_write_request,

    is_mandatory_attribute,
    read_Node_Attribute,
    readall_AddressSpace_Node,
    get_NodeClass,
    get_BrowseName,
    get_DisplayName,
    is_transitive_subtype,
    is_valid_ReferenceTypeId,
    is_NodeId_equal,
    get_TypeDefinition,
    get_Reference_ReferenceType,
    get_Reference_TargetNode,
    get_Reference_IsForward,
    get_Node_RefIndexEnd,
    get_RefIndex_Reference,
    get_Value_StatusCode,
    read_AddressSpace_clear_value,
    read_AddressSpace_free_variant,
    is_local_service_treatment,
    set_local_service_treatment,
    get_user_authorization ,
    get_Executable,
    get_InputArguments,
    get_conv_Variant_ValueRank,
    get_conv_Variant_Type,
    read_variable_compat_type,
    check_object_has_method,
    check_nodeId_isValid,
    is_IndexRangeDefined

LOCAL_OPERATIONS

    sc_operation, parent_nid, new_nid
      <-- check_add_nodes_item_params
        (p_parentNid, p_refTypeId, p_reqNodeId, p_browseName, p_nodeClass, p_typeDefId) =
    PRE
        p_parentNid : t_ExpandedNodeId_i &
        p_parentNid : t_ExpandedNodeId &
        p_refTypeId : t_NodeId_i &
        p_refTypeId : t_NodeId &
        p_reqNodeId : t_ExpandedNodeId_i &
        p_browseName : t_QualifiedName_i &
        p_browseName : t_QualifiedName &
        p_nodeClass : t_NodeClass_i &
        p_nodeClass : t_NodeClass &
        p_typeDefId : t_ExpandedNodeId_i &
        (p_nodeClass :{e_ncl_Object, e_ncl_Variable} => p_typeDefId : t_ExpandedNodeId)
    THEN
        sc_operation,
        parent_nid,
        new_nid
        :(
            sc_operation : t_StatusCode_i &
            sc_operation : {e_sc_ok,
                            e_sc_bad_parent_node_id_invalid,
                            e_sc_bad_reference_type_id_invalid,
                            e_sc_bad_reference_not_allowed,
                            e_sc_bad_node_id_rejected,
                            e_sc_bad_node_id_exists,
                            // bad_node_class_invalid => already checked
                            // e_sc_bad_browse_name_invalid => already checked
                            e_sc_bad_browse_name_duplicated,
                            //bad_node_attributes_invalid => already checked
                            e_sc_bad_type_definition_invalid,
                            e_sc_bad_out_of_memory }  &
            parent_nid : t_NodeId_i &
            new_nid : t_NodeId_i &
            (sc_operation = e_sc_ok =>
                /* Parent node is valid */
                p_parentNid : dom(conv_ExpandedNodeId_NodeId) &
                parent_nid = conv_ExpandedNodeId_NodeId(p_parentNid) &
                parent_nid : ran(a_NodeId) &
                /* Reference type is valid */
                p_refTypeId : Type_IsReferenceTypeIdValid &
                new_nid : t_NodeId &
                new_nid /: ran(a_NodeId) &
                (p_reqNodeId : t_ExpandedNodeId =>
                    p_reqNodeId : dom(conv_ExpandedNodeId_NodeId) & new_nid = conv_ExpandedNodeId_NodeId(p_reqNodeId)) &
                /* Type definition is valid if node is an object or variable */
                (p_nodeClass = e_ncl_Object or p_nodeClass = e_ncl_Variable =>
                 p_typeDefId : t_ExpandedNodeId)
            ) &
            (not(sc_operation = e_sc_ok) => new_nid = c_NodeId_indet)
        )
    END
    ;

    sc_operation
      <-- local_treat_add_nodes_item (p_parentNid, p_refTypeId, p_newNodeId, p_browseName, p_nodeClass, p_nodeAttributes, p_typeDefId) =
    PRE
        p_parentNid : t_NodeId_i &
        p_parentNid : t_NodeId &
        p_refTypeId : t_NodeId_i &
        p_refTypeId : t_NodeId &
        p_newNodeId : t_NodeId_i &
        p_newNodeId : t_NodeId &
        p_newNodeId /: ran(a_NodeId) &
        p_browseName : t_QualifiedName_i &
        p_browseName : t_QualifiedName &
        p_nodeClass : t_NodeClass_i &
        p_nodeClass : t_NodeClass &
        p_nodeAttributes : t_NodeAttributes_i &
        p_nodeAttributes : t_NodeAttributes &
        p_typeDefId : t_ExpandedNodeId_i
    THEN
        sc_operation,
        d_adsp_nodes_variables
        :(
            d_adsp_nodes_invariant &
            sc_operation : t_StatusCode_i &
            sc_operation : {e_sc_ok,
                            // temporary to indicate unsupported node classes
                            e_sc_bad_node_class_invalid,
                            e_sc_bad_out_of_memory }  &
            (sc_operation = e_sc_ok => p_newNodeId : ran(a_NodeId))
        )
    END

OPERATIONS

    /* LOCAL_OPERATIONS */


    sc_operation, parent_nid, new_nid
      <-- check_add_nodes_item_params
        (p_parentNid, p_refTypeId, p_reqNodeId, p_browseName, p_nodeClass, p_typeDefId) =
    VAR
        l_bres,
        l_local_server_exp_node_id,
        l_node_id,
        l_node_exists,
        l_node,
        l_node_class
    IN
        sc_operation := e_sc_bad_unexpected_error;
        parent_nid := c_NodeId_indet;
        new_nid := c_NodeId_indet;
        l_bres := FALSE;
        /* Validate parent node */
        l_local_server_exp_node_id, l_node_id <-- getall_conv_ExpandedNodeId_NodeId(p_parentNid);
        IF l_local_server_exp_node_id = TRUE
        THEN
            l_node_exists, l_node <-- readall_AddressSpace_Node(l_node_id);
            IF l_node_exists = TRUE
            THEN
                l_bres := TRUE;
                parent_nid := l_node_id
            ELSE
                sc_operation := e_sc_bad_parent_node_id_invalid
            END
        ELSE
            sc_operation := e_sc_bad_parent_node_id_invalid
        END
        ;
        /* Validates reference type */
        IF l_bres = TRUE
        THEN
            l_bres <-- is_valid_ReferenceTypeId(p_refTypeId);
            IF l_bres = FALSE
            THEN
                sc_operation := e_sc_bad_reference_type_id_invalid
            END
        END
        ;
        IF l_bres = TRUE
        THEN
            /* Check it is a hierarchical reference type (minimal condition) */
            l_bres <-- is_transitive_subtype(p_refTypeId, c_HierarchicalReferences_Type_NodeId);
            IF l_bres = FALSE
            THEN
                sc_operation := e_sc_bad_reference_type_id_invalid
            END
            /* TODO: check reference type allowed given parent node class and new node class: only possible for "known" semantic */
        END
        ;
        /* Validates requested NodeId (or Generates a fresh one if not defined) */
        IF l_bres = TRUE
        THEN
            IF p_reqNodeId /= c_ExpandedNodeId_indet
            THEN
                l_local_server_exp_node_id, l_node_id <-- getall_conv_ExpandedNodeId_NodeId(p_reqNodeId);
                IF l_local_server_exp_node_id = TRUE
                THEN
                    l_node_exists, l_node <-- readall_AddressSpace_Node(l_node_id);
                    IF l_node_exists = TRUE
                    THEN
                        new_nid := l_node_id
                    ELSE
                        l_bres := FALSE;
                        sc_operation := e_sc_bad_node_id_exists
                    END
                ELSE
                    l_bres := FALSE;
                    sc_operation := e_sc_bad_node_id_rejected
                END
            ELSE
                /* TODO: generate a fresh node id */
                l_bres := FALSE;
                sc_operation := e_sc_bad_node_id_rejected
            END
        END
        ;
        /* TODO: check uniqueness of BrowseName (only in TypeDefinition and InstanceDeclaration).
           Or for all "same relationship with the parent" as stated by bad status code ?
           Note: it should use browse service / ref iterator which is in another branch or C implem only.
        */
        /* Validtes TypeDefinition if defined (mandatory for nodes of class Object or Variable) */
        IF p_typeDefId /= c_ExpandedNodeId_indet
        THEN
            l_local_server_exp_node_id, l_node_id <-- getall_conv_ExpandedNodeId_NodeId(p_reqNodeId);
            IF l_local_server_exp_node_id = TRUE
            THEN
                l_node_exists, l_node <-- readall_AddressSpace_Node(l_node_id);
                IF l_node_exists = TRUE
                THEN
                    l_node_class <-- get_NodeClass(l_node);
                    IF l_node_class = e_ncl_VariableType & p_nodeClass = e_ncl_Variable
                    THEN
                        skip
                    ELSIF l_node_class = e_ncl_ObjectType & p_nodeClass = e_ncl_Object
                    THEN
                        skip
                    ELSE
                        l_bres := FALSE;
                        sc_operation := e_sc_bad_type_definition_invalid
                    END
                ELSE
                    l_bres := FALSE;
                    sc_operation := e_sc_bad_type_definition_invalid
                END
            END /* ELSE: impossible to check type definition class => assume it is expected node class */
        END
        ;
        IF l_bres = TRUE
        THEN
            sc_operation := e_sc_ok
        END
    END
    ;

    sc_operation
    <-- local_treat_add_nodes_item (p_parentNid, p_refTypeId, p_newNodeId, p_browseName, p_nodeClass, p_nodeAttributes, p_typeDefId) =
    BEGIN
        sc_operation := e_sc_ok
    END
    ;

    /* OPERATIONS */
    sc_operation, new_nodeId
      <-- treat_add_nodes_item (p_parentExpNid, p_refTypeId, p_reqExpNodeId, p_browseName, p_nodeClass, p_nodeAttributes, p_typeDefId) =
    VAR
        l_sc,
        l_parent_nid,
        l_new_nid
    IN
        l_sc, l_parent_nid, l_new_nid
          <-- check_add_nodes_item_params
            (p_parentExpNid, p_refTypeId, p_reqExpNodeId, p_browseName, p_nodeClass, p_typeDefId);
        IF l_sc = e_sc_ok
        THEN
            /* Check user right ? Or before ? */
            skip
        END
        ;
        IF l_sc = e_sc_ok
        THEN
            l_sc <-- local_treat_add_nodes_item(l_parent_nid, p_refTypeId, l_new_nid, p_browseName, p_nodeClass, p_nodeAttributes, p_typeDefId)
        END
        ;
        sc_operation := l_sc;
        IF sc_operation = e_sc_ok
        THEN
            new_nodeId := l_new_nid
        ELSE
            new_nodeId := c_NodeId_indet
        END
    END

END
